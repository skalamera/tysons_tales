# -*- coding: utf-8 -*-
"""use canvas to generate and display the code for a...

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vE1xDkRJ6dM8dj0KU1bEjS4bKdmLD4Vz

Okay, this sounds like a fantastic and ambitious project! Building an app that generates personalized, illustrated, and narrated 'choose your own adventure' children's books is a wonderful idea. Let's break down how we can conceptualize and structure the code for such an application.

I'll act as your "canvas" to outline the design and then provide code snippets to illustrate how different parts might work.

**Overall App Architecture**

We can think of this app as having a few major components:

1.  **Frontend (User Interface - UI):** This is what the user sees and interacts with. It will handle input for personalization, display the story, and present choices.
2.  **Backend (Story Generation & Logic):** This is the "brain" of the app. It will take the user's preferences, generate story content, manage story progression, and interface with other services for illustrations and audio.
3.  **Illustration Service:** A module or external service that generates images based on story content.
4.  **Audio Service (Text-to-Speech - TTS):** A module or external service that converts story text into spoken audio.
5.  **Database:** To store user profiles, saved characters, story progress, and potentially story templates.

Let's dive into each part.

**1. Frontend (User Interface)**

The frontend will guide the user through the personalization process and then display the interactive story.

**Key Screens/Components:**

* **Welcome/Main Menu Screen:**
    * Option to start a new story.
    * Option to load a saved character.
    * Option to view/manage saved characters.
* **Character Creation/Selection Screen:**
    * Input fields for:
        * Character Name (text input)
        * Gender (dropdown: e.g., girl, boy, prefer not to say/neutral) - this will help with pronouns in the story.
        * Role (dropdown: e.g., brave knight, curious astronaut, clever detective, magical wizard, adventurous pirate).
        * Personality (checkboxes or dropdown: e.g., brave, funny, kind, shy, inquisitive, determined).
    * Button to "Save Character" (if creating a new one).
    * List of previously saved characters to choose from.
* **Story Theme Selection Screen:**
    * Options like: Fantasy Kingdom, Space Adventure, Mysterious Forest, Undersea World, Time Travel.
* **Additional Personalization Screen (Optional but nice):**
    * Favorite color (can be subtly woven into illustrations or descriptions).
    * Favorite animal (could be a companion or a character they meet).
    * A special wish or goal for the character.
* **Story Display Screen:**
    * Area for the current story text.
    * Display area for the illustration.
    * Audio controls (play, pause, replay current narration).
    * Buttons for making choices (e.g., "Open the mysterious box" or "Leave the box and continue on the path").
* **User Profile/Saved Characters Management Screen:**
    * List, edit, or delete saved custom characters.

**Frontend Code Snippet Example (Conceptual - e.g., using a JavaScript framework like React/Vue/Angular)**

Let's imagine a simplified character creation form component.

```javascript
// Conceptual Frontend Component: CharacterForm.js

// Props:
// - onSaveCharacter: function to call when character is saved
// - existingCharacter: (optional) character data to pre-fill for editing

function CharacterForm({ onSaveCharacter, existingCharacter }) {
  const [name, setName] = useState(existingCharacter?.name || '');
  const [gender, setGender] = useState(existingCharacter?.gender || 'girl');
  const [role, setRole] = useState(existingCharacter?.role || 'knight');
  const [personalities, setPersonalities] = useState(existingCharacter?.personalities || []); // e.g., ['brave', 'curious']

  const handlePersonalityChange = (personality) => {
    if (personalities.includes(personality)) {
      setPersonalities(personalities.filter(p => p !== personality));
    } else {
      setPersonalities([...personalities, personality]);
    }
  };

  const handleSubmit = () => {
    const characterData = { name, gender, role, personalities };
    // Here you would typically send this data to the backend or a state management system
    console.log("Character Data:", characterData);
    if (onSaveCharacter) {
      onSaveCharacter(characterData);
    }
    // Potentially navigate to the next screen (theme selection)
  };

  return (
    <div className="character-form">
      <h2>Create Your Character</h2>
      <div>
        <label>Name:</label>
        <input type="text" value={name} onChange={(e) => setName(e.target.value)} />
      </div>
      <div>
        <label>Gender:</label>
        <select value={gender} onChange={(e) => setGender(e.target.value)}>
          <option value="girl">Girl</option>
          <option value="boy">Boy</option>
          <option value="neutral">Neutral</option>
        </select>
      </div>
      <div>
        <label>Role:</label>
        <select value={role} onChange={(e) => setRole(e.target.value)}>
          <option value="knight">Brave Knight</option>
          <option value="astronaut">Curious Astronaut</option>
          <option value="detective">Clever Detective</option>
          {/* Add more roles */}
        </select>
      </div>
      <div>
        <label>Personality Traits (select one or more):</label>
        {['brave', 'funny', 'kind', 'shy', 'inquisitive'].map(trait => (
          <div key={trait}>
            <input
              type="checkbox"
              id={trait}
              checked={personalities.includes(trait)}
              onChange={() => handlePersonalityChange(trait)}
            />
            <label htmlFor={trait}>{trait.charAt(0).toUpperCase() + trait.slice(1)}</label>
          </div>
        ))}
      </div>
      <button onClick={handleSubmit}>Save and Continue</button>
    </div>
  );
}

// To use this (simplified):
// <CharacterForm onSaveCharacter={(data) => console.log('Character saved:', data)} />
```

**Implementation Instructions (Frontend):**

1.  **Choose a Framework:** Decide if you're building for the web (React, Vue, Angular) or mobile (React Native, Flutter, Swift for iOS, Kotlin for Android).
2.  **Component Structure:** Break down the UI into reusable components as shown above.
3.  **State Management:** Use built-in state management (like React's `useState` and `useContext`) or libraries (like Redux, Zustand, Vuex) to manage user inputs and application state.
4.  **Navigation:** Implement routing to move between different screens.
5.  **API Calls:** Use `fetch` or libraries like `axios` to communicate with the backend.

**2. Backend (Story Generation & Logic)**

This is where the magic happens! The backend will construct the story dynamically.

**Key Modules/Functionality:**

* **Story Engine:**
    * Manages story templates or "story graphs." A story can be represented as a tree or graph where each node is a story segment.
    * Each node would contain:
        * `id`: Unique identifier for this story part.
        * `text_template`: The text of this part of the story, with placeholders for character name, pronouns, etc. (e.g., "{character_name} the {character_role} entered the {theme_setting}. {pronoun_he_she_they} felt {personality_trait}.").
        * `illustration_prompt_template`: A template to generate a prompt for the illustration service (e.g., "A {gender} {character_role} named {character_name}, looking {personality_trait}, in a {theme_setting_visuals}. Children's book style.").
        * `choices`: An array of choice objects, each leading to another `id`.
            * `choice_text`: Text displayed to the user for the decision.
            * `next_node_id`: The ID of the story segment to go to if this choice is selected.
            * `conditions` (optional): Conditions based on character traits or previous choices for this choice to be available.
    * Function to get the starting node of a story based on the theme.
    * Function to get the next story segment based on the current node and user's choice.
    * Logic to personalize text using character data (e.g., replacing placeholders).
* **Character Management:**
    * API endpoints to save, load, update, and delete custom characters from the database.
* **Pronoun Helper:**
    * A utility to determine correct pronouns (he/she/they, him/her/them, his/her/their) based on the selected gender.

**Backend Code Snippet Example (Conceptual - e.g., Python with Flask/Django)**
"""

# Conceptual Backend: story_engine.py (Python-like pseudocode)

class StoryEngine:
    def __init__(self, story_templates_db, character_data):
        self.story_templates = story_templates_db # This would load story structures
        self.character = character_data
        self.pronouns = self._get_pronouns(character_data.get('gender'))

    def _get_pronouns(self, gender):
        if gender == 'boy':
            return {'subject': 'he', 'object': 'him', 'possessive': 'his', 'reflexive': 'himself'}
        elif gender == 'girl':
            return {'subject': 'she', 'object': 'her', 'possessive': 'her', 'reflexive': 'herself'}
        else: # Neutral or prefer not to say
            return {'subject': 'they', 'object': 'them', 'possessive': 'their', 'reflexive': 'themself'} # or themselves

    def _personalize_text(self, text_template):
        # Basic placeholder replacement
        # A more sophisticated system might use templating engines like Jinja2
        text = text_template.replace("{character_name}", self.character.get('name', 'Hero'))
        text = text.replace("{character_role}", self.character.get('role', 'adventurer'))

        # Pronoun replacement
        text = text.replace("{he_she_they}", self.pronouns['subject'])
        text = text.replace("{him_her_them}", self.pronouns['object'])
        text = text.replace("{his_her_their}", self.pronouns['possessive'])

        # Personality integration (could be more complex, influencing events or dialogue variations)
        # For simplicity, just inserting one if available
        if self.character.get('personalities'):
            text = text.replace("{personality_trait}", self.character.get('personalities')[0])
        else:
            text = text.replace("{personality_trait}", "brave") # default

        # Theme integration (example)
        text = text.replace("{theme_setting}", self.character.get('theme_details', {}).get('setting_name', 'mysterious place'))
        return text

    def get_story_node(self, node_id):
        node_data = self.story_templates.get(node_id) # Fetch node from "database" of templates
        if not node_data:
            return None

        personalized_text = self._personalize_text(node_data['text_template'])

        # Personalize illustration prompt similarly
        illustration_prompt = self._personalize_text(node_data['illustration_prompt_template'])

        # Filter choices based on conditions if any (advanced)
        available_choices = []
        for choice in node_data.get('choices', []):
            # Add logic here if choices depend on character traits or story state
            available_choices.append({
                'text': self._personalize_text(choice['choice_text']),
                'next_node_id': choice['next_node_id']
            })

        return {
            'story_text': personalized_text,
            'illustration_prompt': illustration_prompt,
            'choices': available_choices,
            'current_node_id': node_id
        }

    def get_initial_story_node(self, theme):
        # This would look up the starting node ID for a given theme
        # Example: if theme is "fantasy", start_node_id = "fantasy_start_1"
        start_node_id = self.story_templates.get_theme_start_node(theme)
        if start_node_id:
            return self.get_story_node(start_node_id)
        return None

# --- Example Story Template Structure (could be in JSON or a database) ---
# story_templates_db = {
#   "fantasy_start_1": {
#     "text_template": "{character_name} the {character_role} stood at the edge of the Whispering Woods. {he_she_they} felt very {personality_trait}. A narrow path led into the shadows.",
#     "illustration_prompt_template": "Children's book illustration of {character_name} as a {gender} {character_role}, looking {personality_trait}, at the entrance of a mystical forest called Whispering Woods. {theme_visual_details}",
#     "choices": [
#       {"choice_text": "Enter the Whispering Woods.", "next_node_id": "fantasy_woods_path"},
#       {"choice_text": "Look for another way around.", "next_node_id": "fantasy_around_woods"}
#     ]
#   },
#   "fantasy_woods_path": { ... content ... }
#   // more nodes
# }

"""**Implementation Instructions (Backend):**

1.  **Choose a Framework/Language:** Python (Flask, Django), Node.js (Express), Ruby on Rails, Java (Spring), etc.
2.  **API Endpoints:** Design RESTful API endpoints for:
    * `POST /story/start` (input: character data, theme; output: first story node)
    * `POST /story/choice` (input: current node id, choice id; output: next story node)
    * `POST /character` (input: character data; output: saved character)
    * `GET /character/{user_id}` (output: list of saved characters for a user)
3.  **Story Structure:** Plan how you will store your story templates. JSON files are good for starting, but a database (NoSQL like MongoDB or relational like PostgreSQL) would be better for scalability and easier management of complex stories.
4.  **Templating Engine:** Use a templating engine (like Jinja2 for Python, Handlebars for Node.js) for more robust text personalization.

**3. Illustration Service**

This service will generate images based on prompts from the Story Engine.

**Options:**

* **AI Image Generation APIs:**
    * OpenAI's DALL-E API
    * Stability AI's Stable Diffusion API (or run your own model)
    * Other commercial or open-source models.
* **Pre-made Illustrations:** For a simpler approach, you could have a library of pre-made illustrations tagged with keywords, and your service tries to match the best one. This offers less dynamic generation but more control over style and content.

**Conceptual Code (Backend interacting with an AI Image Generation API):**
"""

from google.colab import drive
drive.mount('/content/drive')

# Conceptual Python: illustration_service.py
import requests # For making HTTP requests to an API
import os

# Assume API_KEY and API_ENDPOINT are configured
ILLUSTRATION_API_KEY = os.environ.get("ILLUSTRATION_API_KEY")
ILLUSTRATION_API_ENDPOINT = "https://api.example-illustration.com/v1/images/generations" # Placeholder

def generate_illustration(prompt_text, art_style="children's book illustration"):
    headers = {
        "Authorization": f"Bearer {ILLUSTRATION_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "prompt": f"{prompt_text}, {art_style}, vibrant colors, friendly",
        "n": 1, # Number of images to generate
        "size": "512x512" # Desired image size
    }
    try:
        response = requests.post(ILLUSTRATION_API_ENDPOINT, headers=headers, json=payload)
        response.raise_for_status() # Raise an exception for bad status codes
        image_url = response.json()['data'][0]['url'] # Example path to image URL
        return image_url
    except requests.exceptions.RequestException as e:
        print(f"Error generating illustration: {e}")
        return "path/to/default_placeholder_image.png" # Fallback

# --- In your story engine when preparing a node ---
# illustration_prompt = "A brave knight named Arthur meeting a friendly dragon in a sunny meadow."
# image_url = illustration_service.generate_illustration(illustration_prompt)
# story_node_data['illustration_url'] = image_url



"""**Implementation Instructions (Illustration Service):**

1.  **Choose a Service/Model:** Research and select an image generation API or model that fits your budget and quality requirements.
2.  **API Integration:** Write code to securely call the API, send prompts, and receive image URLs or image data.
3.  **Prompt Engineering:** This is crucial! Crafting good prompts is key to getting desired illustrations. Your `illustration_prompt_template` in the story nodes will be very important.
4.  **Error Handling & Fallbacks:** Implement fallbacks in case the image generation fails (e.g., show a generic image or no image).

**4. Audio Service (Text-to-Speech - TTS)**

This service converts the story text into spoken audio.

**Options:**

* **Cloud TTS APIs:**
    * Google Cloud Text-to-Speech
    * Amazon Polly
    * Microsoft Azure Cognitive Services Speech
* **Browser-based TTS:** The `SpeechSynthesis` API available in modern web browsers. This is simpler for web apps and can be free, but voice quality and availability vary by browser/OS.
* **Open-source TTS engines:** e.g., eSpeak, Mozilla TTS (can be self-hosted).

**Conceptual Code (Backend interacting with a Cloud TTS API, or Frontend using Web Speech API):**

**A) Backend approach (generates audio file URL):**
"""

# Conceptual Python: audio_service.py
import requests
import os

TTS_API_KEY = os.environ.get("TTS_API_KEY")
TTS_API_ENDPOINT = "https://api.example-tts.com/v1/audio" # Placeholder

def generate_audio(text_to_speak, voice_id="child_friendly_female"): # Voice ID specific to TTS provider
    headers = {
        "Authorization": f"Bearer {TTS_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "text": text_to_speak,
        "voice": voice_id,
        "output_format": "mp3"
    }
    try:
        response = requests.post(TTS_API_ENDPOINT, headers=headers, json=payload)
        response.raise_for_status()
        audio_url = response.json()['data']['url'] # Example path to audio file URL
        return audio_url
    except requests.exceptions.RequestException as e:
        print(f"Error generating audio: {e}")
        return None # Fallback

# --- In your story engine when preparing a node ---
# story_text = "Hello, {character_name}! Welcome to the adventure."
# personalized_story_text = story_engine._personalize_text(story_text)
# audio_url = audio_service.generate_audio(personalized_story_text)
# story_node_data['audio_url'] = audio_url

"""**B) Frontend approach (using Web Speech API - JavaScript):**

```javascript
// Conceptual Frontend JavaScript: speechUtils.js

function speakText(text, lang = 'en-US') {
  if ('speechSynthesis' in window) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = lang;
    
    // Optional: Find a specific voice if desired
    // const voices = window.speechSynthesis.getVoices();
    // utterance.voice = voices.find(voice => voice.name === 'Your Preferred Voice Name');

    window.speechSynthesis.cancel(); // Cancel any ongoing speech
    window.speechSynthesis.speak(utterance);
  } else {
    console.warn("Browser does not support Speech Synthesis.");
    // You might want to provide a fallback or inform the user.
  }
}

function stopSpeaking() {
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
  }
}

// --- In your StoryDisplay component ---
// useEffect(() => {
//   if (currentStorySegment.text) {
//     speakText(currentStorySegment.text);
//   }
//   return () => stopSpeaking(); // Stop speaking when component unmounts or text changes
// }, [currentStorySegment.text]);
```

**Implementation Instructions (Audio Service):**

1.  **Choose TTS Method:** Decide between server-side generation (more control, consistent voice) or client-side (simpler, potentially free but less control).
2.  **API/Library Integration:** If using an API, integrate it similarly to the illustration service. If using Web Speech API, ensure you handle browser compatibility and voice selection.
3.  **Audio Controls:** The frontend will need play/pause/replay buttons that interact with the audio (either an `<audio>` tag for server-generated files or the `SpeechSynthesis` API).

**5. Database**

You'll need a database to store persistent information.

**Data to Store:**

* **User Accounts (if you have logins):** Usernames, hashed passwords, email, etc.
* **Saved Characters:**
    * `user_id` (if applicable)
    * `character_id` (unique)
    * `name`
    * `gender`
    * `role`
    * `personalities` (array)
    * Other custom fields (favorite color, animal)
* **Story Templates/Content (Alternative to JSON files):**
    * Story graph nodes, text templates, illustration prompt templates, choice definitions. This makes it easier to update and add new stories without redeploying code.
* **User Story Progress (Optional):**
    * `user_id`
    * `story_id`
    * `current_node_id`
    * `choices_made` (history)
    This allows users to resume stories.

**Database Choice:**

* **NoSQL (e.g., MongoDB, Firebase Firestore):** Good for flexible schemas, especially for story content and character data which might evolve.
* **SQL (e.g., PostgreSQL, MySQL, SQLite):** Good for structured data and relationships, especially if you have complex user management or defined relations between story elements. SQLite is great for getting started quickly or for local development.

**Conceptual Schema (Simplified JSON-like for a Character):**

```json
{
  "character_id": "char_123xyz",
  "user_id": "user_abc789", // Optional, if you have user accounts
  "name": "Luna",
  "gender": "girl",
  "role": "astronaut",
  "personalities": ["curious", "brave"],
  "favorite_color": "starlight_silver",
  "favorite_animal": "space_fox",
  "saved_at": "2025-05-30T10:00:00Z"
}
```

**Implementation Instructions (Database):**

1.  **Choose Database Type:** Select based on your needs for structure, scalability, and ease of use.
2.  **Define Schemas:** Plan out the structure of your data.
3.  **ORM/ODM (Optional but Recommended):** Use an Object-Relational Mapper (like SQLAlchemy for Python with SQL DBs, Prisma) or Object-Document Mapper (like Mongoose for Node.js with MongoDB) to interact with your database more easily from your backend code.

**Putting It All Together (Development Steps Overview)**

1.  **Core Story Logic First:**
    * Design your story node structure (`text_template`, `choices`, etc.).
    * Implement the basic `StoryEngine` in your chosen backend language to navigate a simple, hardcoded story (text-only for now).
    * Test fetching story parts and making choices via simple API calls (e.g., using Postman or curl).
2.  **Basic Frontend:**
    * Create a simple UI to display text and choice buttons.
    * Connect it to your backend API to fetch and display the story.
3.  **Personalization:**
    * Add character creation forms to the frontend.
    * Modify the backend to accept character parameters and use them in the `StoryEngine` to personalize the text.
    * Implement saving/loading characters (initially maybe just in browser local storage, then move to backend database).
4.  **Illustration Integration:**
    * Sign up for an image generation API.
    * Add the `illustration_prompt_template` to your story nodes.
    * Implement the `IllustrationService` in the backend.
    * Modify the frontend to display the generated images.
5.  **Audio Integration:**
    * Choose your TTS method.
    * Integrate it (either backend generating audio files/URLs or frontend using Web Speech API).
    * Add audio controls to the frontend.
6.  **Database Implementation:**
    * Set up your chosen database.
    * Implement backend logic to store and retrieve user characters, and potentially story content itself.
7.  **Refine and Expand:**
    * Add more story themes, roles, and personalization options.
    * Improve prompt engineering for better illustrations.
    * Gather user feedback and iterate.

This is a significant project, so breaking it down into these manageable steps will be key. Start with the core story experience and then layer on the more advanced features like illustrations and audio.

Remember to keep the tone positive and encouraging in the app itself, as it's for children! Good luck, this sounds like a very rewarding app to build! Let me know if you'd like to dive deeper into any specific part.
"""

import os
from dotenv import load_dotenv
from config import OPENAI_API_KEY

# Load environment variables
load_dotenv()

# Set OpenAI API key
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY